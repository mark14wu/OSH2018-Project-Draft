# 可行性报告

## 目录

- [可行性报告](#可行性报告)
    - [目录](#目录)
    - [取得用户程序的控制权](#取得用户程序的控制权)
        - [内核态的解决方案](#内核态的解决方案)
        - [用户态的解决方案](#用户态的解决方案)
    - [如何向用户提供服务](#如何向用户提供服务)
        - [对用户的限制](#对用户的限制)
        - [接受用户更新的方式](#接受用户更新的方式)
            - [1. 用户将更新的源代码发送到我们的应用](#1-用户将更新的源代码发送到我们的应用)
            - [2. 用户将编译完成的更新源代码直接发送给我们](#2-用户将编译完成的更新源代码直接发送给我们)
    - [参考文献](#参考文献)

## 取得用户程序的控制权

在对一个正在运行的工作进程进行更新时，修改它的代码段是一个不可缺少的操作。很显然，这个操作必须是原子的，因为如果程序执行到了正在被修改的代码，它可能会触发一些不可预知的错误。因此我们需要在适当的时候让工作进程交出控制权，在虚拟机完成对工作进程的更新之后，再将控制权交回给工作进程。

关于获得程序的控制权的问题，我们有以下方案

### 内核态的解决方案

在内核中，用中断的方式抢占进程的控制权。在内核态对程序执行相关更新操作后，再将控制权交还给程序。这种做法的**优点**在于**安全**和**高效**，因为代码段默认是不可写的，所以我们需要先更改代码段的读写属性，接着修改代码段内容，再把代码段改回不可写的状态。所以，直接在内核态里完成这些工作可以节省一些系统调用的开销，还可以保证修改代码操作的原子性和程序执行的安全性。

### 用户态的解决方案

* 调试器原理：软中断 (在 x86 上是 INT 3)

  调试器在给一个被调试程序打断点时，先保存断点处的指令，然后用 INT 3 指令去替换原有代码的指令。程序执行到 INT 3 时，操作系统会给调试器发信号。调试器在接收到信号之后会执行以下流程

  * 将 INT 3 改回原来的指令
  * 将代码寻址寄存器回滚一个字节
  * 允许用户和调试器进行交互（读取数据，加新的断点之类）
  * 如果继续执行，调试器会把 INT 3 再填回去，除非用户要求删除断点

  我们可以借鉴调试器的方式，通过软中断获取工作进程的控制权。这种方法的优点是可以**精确**地在某些地址停下来，这对热部署有重要意义。为了更新的安全性，我们通常不希望程序在任意时刻被中止，然后更新。我们希望程序在某些安全的时间节点停下来接收更新，所以软中断的方法可以很好的解决这个问题。软中断的缺点也很明显，它对**效率**的影响非常大。

* 虚拟机接管控制流

  和动态语言类似，我们也可以造一个虚拟机，让每一次函数调用都由虚拟机来处理。这种动态寻址方案优点是**灵活性好**，缺点是**效率不高**，而且**实现比较困难**，尤其是对已经编译好的二进制代码。

  虚拟机和工作进程之间的连接并不是一件轻松的事情，因为工作进程有自己的完整控制流，而且我们假设工作进程并未预先为虚拟机设计通信接口。如果像真正的虚拟机那样对工作进程进行解释，那么它的效率将是我们完全无法忍受的。一个可行的解决方案是，在每次函数调用时，将调用的目标函数地址压栈，并跳转到虚拟机里的控制函数，由虚拟机来处理这次函数调用。

  类似于下面将下面这个程序

  ```c
  #include <stdio.h>

  int fun()
  {
      return 1;
  }
  
  int main()
  {
      printf("%d\n",fun());
      return 0;
  }
  ```

  变换为

  ```c
  #include <stdio.h>

  int vm(int (*pf)())
  {
      return pf();
  }
  
  int fun()
  {
      return 1;
  }
  
  int main()
  {
      printf("%d\n",vm(fun));
      return 0;
  }
  ```

* 信号处理函数获得控制流

  我们可以给工作进程加壳（即给可执行文件增加一些代码），并且这些代码可以在main函数之前执行。在执行“壳”代码时，可以给工作进程注册一些信号处理函数。当需要获得控制流时，外部程序就给工作进程发信号，这时，进程执行中断，进入信号处理函数，这样就达到了获取控制流的目的。通过信号处理函数来获得控制流的方法优点是**执行效率**比较高，缺点是收到信号时停下来的**断点分布**很随机，不一定是我们想要的点。

## 如何向用户提供服务

### 对用户的限制

​    首先，我们对业务逻辑的具体实现进行分析。为了更加准确、安全、方便地实现业务逻辑的修改，我们顺应目前流行的”模块化开发”思想，将应用分为各个模块。这样，我们就可以将应用逻辑的修改精细化描述，具体到某个模块的修改了。

​    随后，我们可以将各个模块分类，分为 **无状态模块** 和 **有状态模块**。**无状态模块** 的定义是，该模块的执行结果（输出）仅仅与模块当前输入有关，而与模块的执行历史无关。也就是说，无论模块之前进行了什么操作，都不会影响到现在模块的输出结果。许多数据处理应用的算法都是属于 **无状态模块**。例如：数据清洗操作（将固定格式的字符流数据转化为包含一定数据结构的结构化数据），并行矩阵乘法（在神经网络的高性能计算中属于性能瓶颈之一）

​    当热部署需求是修改 **无状态模块** 时，热部署的实现将变得相对容易。我们仅仅需要将程序执行的对应模块在合适的时间点进行替换，而不用考虑模块中内部状态的影响。目前解决修改 **无状态模块** 的方案主要是将模块置于动态链接库内加载，如 Windows 操作系统中的`.dll`文件，和 Unix 操作系统的 `.so` 文件。

​    另一方面，某些模块是拥有内部状态的，这些模块的执行结果除了与当前输入数据有关，还会与模块内部储存的一些状态有关，这些模块我们称它为 **有状态模块**。一个 **有状态模块** 的最简单的例子是一个计数器模块：每次调用该模块，会输出被调用次数。这样，我们尽管每次同样调用同一个模块，它的输出结果却不尽相同（每次输出结果都比上一次的输出结果多1）。

​    对于这些 **有状态模块** 而言，为了实现热部署的功能，我们并不能像之前提到的 **无状态模块** 一样处理。如果我们简单地像之前那样，通过动态链接库进行替换，那么这些 **有状态模块** 中的状态就会丢失。还是举计数器的例子：当我们需要对计数器进行更新时，如果是简单地替换掉计数器当前的代码，那么计数器记录的次数就会丢失。这对于某些生产环境是不可接受的严重后果，特别是对于一些庞大且重要的系统，如银行，电信运营商，高铁调度系统等。这些系统一旦发生某些状态数据丢失，会造成巨大的经济损失，甚至造成人员伤亡等。

​    因此，为了避免状态的丢失造成各种数据丢失乃至经济财产损失，我们的一个基本要求就是用户在提供热部署的更新补丁时，这些更新必须是无状态模块。

### 接受用户更新的方式

用户有两种方式向我们提供更新：

#### 1. 用户将更新的源代码发送到我们的应用

用户可以向使用版本管理工具一样将源代码的修正推送到我们的应用中，我们的应用会自动使用文本比较算法比较出需要修改的最小模块，然后应用自动提取出这个模块的源代码。此时的源代码存在一些未定义的外部符号（比如未定义的全局变量，外部函数等等），我们的应用将会通过语法分析工具搜索到这些外部符号，然后自动加上对应的 **extern** 添加到源代码中。经过这样预处理的源代码再进行编译，就可以获得未经连接的 ELF 格式库文件了。

#### 2. 用户将编译完成的更新源代码直接发送给我们

考虑到知识产权保护的需要，一些用户可能不能将源代码对我们开放。因此，我们也支持用户直接发送已编译好，但未链接的 ELF 库文件给我们的应用。

在获取 ELF 文件之后，我们将该 ELF 文件发送到更新器，将文件添加到用户程序的内存空间，完成动态符号链接的工作，并在合适的时间点通过前面的控制权处理程序（“加壳”操作中加入的“壳”程序）接管用户程序的控制流，并修改跳转关系，使得每次调用旧模块时都有相应的跳转指令能重定向到新模块的地址并且执行新模块。这样，一次用户更新就成功部署了。

## 参考文献

1.  [How debuggers work: Part 2 - Breakpoints](https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints)
2.  [玩转utrace](https://www.ibm.com/developerworks/cn/linux/l-cn-utrace/)