# 可行性报告

## 目录

- [可行性报告](#可行性报告)
    - [目录](#目录)
    - [项目简介](#项目简介)
        - [需求分析](#需求分析)
        - [实现大致思路](#实现大致思路)
    - [工作进程控制权的获取](#工作进程控制权的获取)
        - [内核态的解决方案](#内核态的解决方案)
        - [用户态的解决方案](#用户态的解决方案)
    - [代码的修改](#代码的修改)
        - [热更新的粒度](#热更新的粒度)
        - [工作进程代码的修改方式](#工作进程代码的修改方式)
            - [1. 整段替换](#1-整段替换)
            - [2. 新增代码](#2-新增代码)
        - [代码更新的实现方法](#代码更新的实现方法)
    - [向用户提供服务](#向用户提供服务)
        - [对更新的限制](#对更新的限制)
        - [接受更新的方式](#接受更新的方式)
    - [代码优化（可选）](#代码优化（可选）)
        - [性能分析数据指导的优化(PGO)](#性能分析数据指导的优化pgo)
        - [常量折叠](#常量折叠)
    - [参考文献](#参考文献)

## 项目简介

TODO

### 需求分析

### 实现大致思路

## 工作进程控制权的获取

在对一个正在运行的工作进程进行更新时，修改它的代码段是一个不可缺少的操作。很显然，这个操作必须是原子的，因为如果程序执行到了正在被修改的代码，它可能会触发一些不可预知的错误。因此我们需要在适当的时候让工作进程交出控制权，在虚拟机完成对工作进程的更新之后，再将控制权交回给工作进程。

关于获得程序的控制权的问题，我们有以下方案

### 内核态的解决方案

在内核中，用中断的方式抢占进程的控制权。在内核态对程序执行相关更新操作后，再将控制权交还给程序。这种做法的**优点**在于**安全**和**高效**，因为代码段默认是不可写的，所以我们需要先更改代码段的读写属性，接着修改代码段内容，再把代码段改回不可写的状态。所以，直接在内核态里完成这些工作可以节省一些系统调用的开销，还可以保证修改代码操作的原子性和程序执行的安全性。

### 用户态的解决方案

* 调试器原理：软中断 (在 x86 上是 INT 3)

  调试器在给一个被调试程序打断点时，先保存断点处的指令，然后用 INT 3 指令去替换原有代码的指令。程序执行到 INT 3 时，操作系统会给调试器发信号。调试器在接收到信号之后会执行以下流程

  * 将 INT 3 改回原来的指令
  * 将代码寻址寄存器回滚一个字节
  * 允许用户和调试器进行交互（读取数据，加新的断点之类）
  * 如果继续执行，调试器会把 INT 3 再填回去，除非用户要求删除断点

  我们可以借鉴调试器的方式，通过软中断获取工作进程的控制权。这种方法的优点是可以**精确**地在某些地址停下来，这对热部署有重要意义。为了更新的安全性，我们通常不希望程序在任意时刻被中止，然后更新。我们希望程序在某些安全的时间节点停下来接收更新，所以软中断的方法可以很好的解决这个问题。软中断的缺点也很明显，它对**效率**的影响非常大。

* 虚拟机接管控制流

  和动态语言类似，我们也可以造一个虚拟机，让每一次函数调用都由虚拟机来处理。这种动态寻址方案优点是**灵活性好**，缺点是**效率不高**，而且**实现比较困难**，尤其是对已经编译好的二进制代码。

  虚拟机和工作进程之间的连接并不是一件轻松的事情，因为工作进程有自己的完整控制流，而且我们假设工作进程并未预先为虚拟机设计通信接口。如果像真正的虚拟机那样对工作进程进行解释，那么它的效率将是我们完全无法忍受的。一个可行的解决方案是，在每次函数调用时，将调用的目标函数地址压栈，并跳转到虚拟机里的控制函数，由虚拟机来处理这次函数调用。

  类似于下面将下面这个程序

  ```c
  #include <stdio.h>

  int fun()
  {
      return 1;
  }
  
  int main()
  {
      printf("%d\n",fun());
      return 0;
  }
  ```

  变换为

  ```c
  #include <stdio.h>

  int vm(int (*pf)())
  {
      return pf();
  }
  
  int fun()
  {
      return 1;
  }
  
  int main()
  {
      printf("%d\n",vm(fun));
      return 0;
  }
  ```

* 信号处理函数获得控制流

  我们可以给工作进程加壳（即给可执行文件增加一些代码），并且这些代码可以在main函数之前执行。在执行“壳”代码时，可以给工作进程注册一些信号处理函数。当需要获得控制流时，外部程序就给工作进程发信号，这时，进程执行中断，进入信号处理函数，这样就达到了获取控制流的目的。通过信号处理函数来获得控制流的方法优点是**执行效率**比较高，缺点是收到信号时停下来的**断点分布**很随机，不一定是我们想要的点。

```c
#include <stdio.h>  
#include <signal.h>  
#include <unistd.h>

void signal_handle(int sig_num)  
{  
    if(sig_num == SIGUSR1)  
    {  
        printf("\nCapture SIGUSR1\n");  
    }  
    printf("signal_handle running ...\n");  
}  

int main(int argc,char **argv)  
{  
    signal(SIGUSR1, signal_handle);  
    while(1)   
    {  
        sleep(1); putchar('1'); fflush(stdout);
        sleep(1); putchar('2'); fflush(stdout);
        sleep(1); putchar('3'); fflush(stdout);
        sleep(1); putchar('4'); fflush(stdout);
    }  
    return 0 ;  
}
```

例如上面这段代码，main函数在入口处注册了信号处理函数，然后在主循环部分每隔1s就输出一个数字。在接收到SIGUSR1信号时，主线程的控制流就会交给signal_handle函数，因而我们就获得了工作进程的控制流。但是工作进程刚才是在什么地方停下来的我们并不知情，它很可能停在了我们不希望它停下的位置 。

## 代码的修改

### 热更新的粒度

我们要完成**函数级**的动态更新。

具体来说，我们可以动态更新工作进程的任何函数的函数体。函数定义维持不变，在合适的时机对函数体进行修改以实现可能的动态更新。

### 工作进程代码的修改方式

要实现热更新必须要修改代码，我们已经实现了将可执行文件的代码段的属性修改为可写，那么工作进程代码可能的修改方式有以下几种。

#### 1. 整段替换

一个比较简便的方法是将工作进程的代码段整段替换为新的代码，或者将整段函数替换为新的代码，这样做是**不可行的**。

首先，工作进程正在执行的指令不确定，如果将代码段整段替换，将引起无法预知的错误。例如，如果进程正在执行函数递归，整段替换代码后进程的执行进入未知状态，无法继续控制，这是绝对不可行的。

其次，考虑将函数整段替换的方法。即使可以保证替换时机合适，即该函数未在栈中时进行替换，如果新的代码长度超过了原有代码，那么这也是不可行的。其一，原有的可执行文件的代码段可能将无法容纳新的代码，无法做到整段替换。其二，整段替换代码可能需要调整后续代码的内存地址，进而需要调整所有用到直接寻址、寄存器寻址等的指令，还可能需要更新符号表等更多内容。效率低、操作复杂。

#### 2. 新增代码

另一种方法是将新函数作为新增的代码。在原代码调用旧函数时跳转到新的函数入口，函数执行完成后返回到被替换函数返回的地址。这种方法**可行**。

在这里暂时先不考虑如何实现新增代码能被执行，而更详细的考虑怎么样通过新增代码的方式实现热更新以及这种方法的可行性。

以下将被替换的函数称为旧函数，新增的函数代码称为新函数。

 - 旧函数入口处跳转
    
    将旧函数函数体的第一条指令改为跳转指令，跳转到新函数的入口地址。这样做会使每次调用函数时，先jump到旧函数的入口地址，再jump到新函数的入口地址，最后返回到相应的位置。这是一个**简单、通用**的做法，但是**效率低**，而且**对cache不友好**。考虑一种情况，如果我们三次更新同一个函数，不妨称之为函数1、2、3，那么每次调用这个函数会从先跳转到旧函数，之后跳转到函数1，之后函数2，最后函数3，执行并返回，而旧函数和函数1、2、3很可能位于内存不同的页上，这就违反了空间局部性的原理，必定会造成低效、对cache不友好。

 - 在函数调用位置跳转

 将跳转到旧函数的指令直接修改为跳转到新函数。要分为以下几种情况。
 
 1. 如果跳转指令采用直接寻址的方式，这样只需要将地址改为新函数的地址即可。
 2. 如果跳转指令采用寄存器寻址、间接寻址等方式，会有些麻烦。出现这种情况可能的原因比如，使用了函数指针进行函数调用，如果汇编指令是 jump register，这时只有在执行到了这条指令时才能确定要跳转的位置，即register的值，是不是旧函数的地址，而在执行之前很难确定，所以很难实现在函数调用位置跳转。
 
 这样做总体来说效率更高，为了避免寄存器寻址引发的麻烦可以与第一种方法“旧函数入口处跳转”一起使用，可以**提高效率**。

 - 由虚拟机控制跳转

 对于第一种方式“旧函数入口处跳转”，跳转需要两次，而第二种方法能优化第一种方法，那么就自然想到可以用虚拟机控制跳转，即调用旧函数时先跳转到虚拟机的控制部分，由虚拟机决定是否跳转到新函数还是其他函数，这样也是跳转两次，但是相比第一种方式，虚拟机可以从中**获得控制权**，从而更易控制代码的修改、断点的设置等等；**灵活性更高**，可以方便灵活的切换函数。但是与第一种方式同样，**效率低**。

 - 代码全面重排
 
 为了解决效率问题，还有一种策略就是将代码全面重排。使用前三种方法进行热更新，都是新增代码的方法，新增代码就必然会打破程序的空间局部性。为了使前三种方式能获得更高的效率，考虑可以使用mmap系统调用的方法，将代码放入mmap的空间中全面重排。按照时间局部性和空间局部性原理，将修改后的代码，对于经常被调用的函数，调用者和被调用函数尽可能放在临近的内存空间中，结合前三种方式实现动态更新。这样做对前三种方式都在一定程度上**提高了效率**，但是非常**繁琐**，程序中所有含有寻址的指令都要进行修改，代价较大，**不易实现**。

### 代码更新的实现方法

明确了工作进程代码的修改方式，现在研究代码更新的实现方法。根据前面的讨论，整段替换是不可行的，所以这里主要研究新增代码这个方式的实现方法。

新增代码，无论采取哪种新增代码的方式，都有一个问题：新增的代码放在哪里，怎么执行。只是新增代码也不够，必须使旧函数的调用可以跳转到新函数入口，这就涉及另一个问题：旧的代码怎么修改。为了解决这两个问题，需要两个函数：

 - mmap() 系统调用
 
 使用mmap()系统调用解决第一个问题 —— 新增代码放在哪里，怎么执行。

 ```c 
void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
int munmap(void *addr, size_t length);
 ```

 mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。成功执行时，mmap()返回被映射区的指针.
 
 munmap在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。成功执行时，munmap()返回0。当映射关系解除后，对原来映射地址的访问将导致段错误发生。 

 ![mmap1](http://blog.itpub.net/attachment/201707/21/7728585_1500634982Y1eE.jpg)

 ![mmap2](https://images0.cnblogs.com/blog2015/571793/201507/200501092691998.png)
 
 malloc()这些函数也能分配内存空间容纳新增函数代码，使用mmap的优点在于：对于int prot参数，可以指定
 
 PROT_READ：表示内存段内的内容可写；
PROT_WRITE：表示内存段内的内容可读；
PROT_EXEC：表示内存段中的内容可执行；
PROT_NONE：表示内存段中的内容根本没法访问。

 使用malloc直接得到的内存无法执行，而使用mmap可以直接获得**可执行的内存区域**，可以指定内存地址（尽管有时不必要这么做）。将代码存入mmap的空间中可以执行，一个demo如下：（在/demo/jit.c中）

```c
     /*
     * jit
     * http://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html
     */ 
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h> 
    #include <sys/mman.h>
    
    typedef int (*pfun)();
    
    int main(int argc, char *argv[]) {
      // Machine code for:
      //   mov eax, 0
      //   ret
      unsigned char code[] = {0xb8, 0x00, 0x00, 0x00, 0x00, 0xc3};
    
      if (argc < 2) {
        fprintf(stderr, "Usage: ./a.out <integer>\n");
        return 1;
      }
    
      // Overwrite immediate value "0" in the instruction
      // with the user's value.  This will make our code:
      //   mov eax, <user's value>
      //   ret
      int num = atoi(argv[1]);
      memcpy(&code[1], &num, 4);
    
      // Allocate writable/executable memory.
      // Note: real programs should not map memory both writable
      // and executable because it is a security risk.
      void *mem = mmap(NULL, 4096, PROT_WRITE | PROT_EXEC,
                       MAP_ANON | MAP_PRIVATE, -1, 0);
      memcpy(mem, code, sizeof(code));
      mprotect(mem,4096,PROT_EXEC);
    
      // The function will return the user's value.
      int (*func)() = (pfun)mem;
      printf("%d\n",func());
      return 0;
    }
```
    
    在这个demo中，成功将可执行代码写到了mmap的空间中并执行，最后成功返回值并打印在屏幕上。
    

 - mprotect() 系统调用
 
 使用mprotect()系统调用解决第二个问题 —— 旧的代码怎么修改。
 
 ```c
 int mprotect(const void *start, size_t len, int prot);  
 ```
 
 mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。prot同样可以取以下几个值，并且可以用“|”将几个属性合起来使用：
 
 PROT_READ：表示内存段内的内容可写； 
PROT_WRITE：表示内存段内的内容可读； 
PROT_EXEC：表示内存段中的内容可执行； 
PROT_NONE：表示内存段中的内容根本没法访问。

 其中，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。如果执行成功，则返回0；如果执行失败，则返回-1，并且设置errno变量。
 
 可以看到，使用mprotect即可将工作进程的**代码段设置为可写**，即可实现旧代码的修改。一个小demo如下：（在/demo/change_code.c中）
```c
 /*
 * change code segment
 * https://stackoverflow.com/a/12952341
 */ 
#include <stdio.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

int f1()
{
    return 1;
}

int f2()
{
    return 2;
}

int main()
{
    int rc;
    int pagesize;
    char *p;
    int i;

    printf("f1=0x%08X.\n", f1);
    printf("f2=0x%08X.\n", f2);

    printf("f%d\n",f1());
    printf("f%d\n",f2());

    pagesize = sysconf(_SC_PAGE_SIZE);
    printf( "pagesize=%d (0x%08X).\n", pagesize, pagesize );
    if(pagesize == -1) return(2);

    p = (char*) f1;
    printf( "p=0x%08X.\n", p );
    p = (char*) ((size_t) p & ~(pagesize - 1));
    printf( "p=0x%08X.\n", p );

    rc = mprotect( p, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC );
    printf( "rc=%d.\n", rc );
    if(rc!=0) return(2);

    printf("'mprotect()' succeeded.\n");
    memcpy(f2,f1,(size_t)f2-(size_t)f1);

    printf("Write succeeded.\n");
    
    printf("f%d\n",f1());
    printf("f%d\n",f2());

    printf("Call succeeded.\n");

    return 0;
}
```
 
 在这个demo中，将一个程序的代码段设置为可写，写入了另一个程序的代码，并重新修改代码段只读，并成功运行了新的程序。

通过这两个系统调用，解决了代码更新的实现方法问题。我们已经有了充分的进程代码的修改方式和方法。

## 向用户提供服务

### 对更新的限制

​    首先，我们对业务逻辑的具体实现进行分析。为了更加准确、安全、方便地实现业务逻辑的修改，我们顺应目前流行的”模块化开发”思想，将应用分为各个模块。这样，我们就可以将应用逻辑的修改精细化描述，具体到某个模块的修改了。

​    随后，我们可以将各个模块分类，分为 **无状态模块** 和 **有状态模块**。**无状态模块** 的定义是，该模块的执行结果（输出）仅仅与模块当前输入有关，而与模块的执行历史无关。也就是说，无论模块之前进行了什么操作，都不会影响到现在模块的输出结果。许多数据处理应用的算法都是属于 **无状态模块**。例如：数据清洗操作（将固定格式的字符流数据转化为包含一定数据结构的结构化数据），并行矩阵乘法（在神经网络的高性能计算中属于性能瓶颈之一）

​    当热部署需求是修改 **无状态模块** 时，热部署的实现将变得相对容易。我们仅仅需要将程序执行的对应模块在合适的时间点进行替换，而不用考虑模块中内部状态的影响。目前解决修改 **无状态模块** 的方案主要是将模块置于动态链接库内加载，如 Windows 操作系统中的`.dll`文件，和 Unix 操作系统的 `.so` 文件。

​    另一方面，某些模块是拥有内部状态的，这些模块的执行结果除了与当前输入数据有关，还会与模块内部储存的一些状态有关，这些模块我们称它为 **有状态模块**。一个 **有状态模块** 的最简单的例子是一个计数器模块：每次调用该模块，会输出被调用次数。这样，我们尽管每次同样调用同一个模块，它的输出结果却不尽相同（每次输出结果都比上一次的输出结果多1）。

​    对于这些 **有状态模块** 而言，为了实现热部署的功能，我们并不能像之前提到的 **无状态模块** 一样处理。如果我们简单地像之前那样，通过动态链接库进行替换，那么这些 **有状态模块** 中的状态就会丢失。还是举计数器的例子：当我们需要对计数器进行更新时，如果是简单地替换掉计数器当前的代码，那么计数器记录的次数就会丢失。这对于某些生产环境是不可接受的严重后果，特别是对于一些庞大且重要的系统，如银行，电信运营商，高铁调度系统等。这些系统一旦发生某些状态数据丢失，会造成巨大的经济损失，甚至造成人员伤亡等。

​    因此，为了避免状态的丢失造成各种数据丢失乃至经济财产损失，我们的一个基本要求就是用户在提供热部署的更新补丁时，这些更新必须是无状态模块。

这些无状态模块在编程语言中主要有四种具体形式：
- 更改函数
- 增加函数
- 更改全局变量
- 增加全局变量

### 接受更新的方式

用户有两种方式向我们提供更新：

1. 用户将更新的源代码发送到我们的应用

用户可以向使用版本管理工具一样将源代码的修正推送到我们的应用中，我们的应用会自动使用文本比较算法比较出需要修改的最小模块，然后我们的工具可以自动提取出这个最小模块的源代码。此时的源代码可能存在一些未定义的外部符号（比如未定义的全局变量，外部函数等等），我们的应用可以通过语法分析等手段搜索到这些外部符号，然后自动加上对应的 **extern** 添加到源代码中。经过这样预处理的源代码再进行编译，就可以获得未经连接的 ELF 格式库文件了。

2. 用户将编译完成的更新源代码直接发送给我们

考虑到知识产权保护的需要，一些用户可能不能将源代码对我们开放。因此，我们也支持用户直接发送已编译好，但未链接的 ELF 库文件给我们的应用。

在获取 ELF 文件之后，我们将该 ELF 文件发送到更新器，将文件添加到工作进程的内存空间，完成动态符号链接的工作，并在合适的时间点通过前面的控制权处理程序（“加壳”操作中加入的“壳”程序）接管工作进程的控制流，并修改跳转关系，使得每次调用旧模块时都有相应的跳转指令能重定向到新模块的地址并且执行新模块。这样，一次用户更新就成功部署了。

## 代码优化（可选）

为了实现工作进程的热部署，我们不得不对工作进程的控制流进行一些干扰。这些干扰会导致程序性能的下降。因此，我们应该想办法弥补这些性能损失。

### 性能分析数据指导的优化(PGO)

PGO(profile-guided optimization) 是一种广泛应用于即时编译（JIT, just-in-time compilation）中的优化技术。它的基本思想是使用运行时数据来指导程序优化。程序在运行时会产生一些数据，如各个函数的调用频率，热点路径等。这些数据在提前编译（ahead-of-time compilation）时是无法获取和利用的。

* 热点路径

  我们可以运行时反复调用的函数放在同一个或相邻的几个页里，这样可以使得CPU缓存命中率大大提高。

* 运行时内联

  通过分析性能数据，决定是否将某些函数在运行时内联。

### 常量折叠

对某些需要计算的常量，我们可以用计算出来的值去替代计算过程。至于哪些常量是可以被安全地折叠，可能需要人为提供一些配置才能确定。

结论

对于程序热部署这个问题，我们采用了自顶而下的设计思想，将原问题分解成了几个阶段的问题。在上文中，我们对这几个阶段的解决方案进行了详尽地讨论。最后，我们得出了以下几种可行的解决方案组合，作为我们备选的实现方法。

Plan A

- 给工作进程注册信号处理函数
  - 加壳法
  - ptrace 法

- 工作进程/守护进程在接收到更新信号后，为工作进程添加软中断，让进程停在安全的更新点
- 读取 elf 文件提供的更新，将更改的函数、新增的函数和新增的全局变量装入工作进程的地址空间中
- 将程序中对旧函数的调用变为对新函数的调用
  - 函数是位置无关码
    - 没有任何信息时：在旧函数入口处加跳转，跳转到新函数入口
    - 没有通过函数指针调用的情况：在程序中搜索对旧地址的调用指令，替换为对新地址的调用
  - 函数不是位置无关码
    - 新代码比旧代码短且没有正在栈中的递归调用：原地替换代码
- 更新镜像的制作方法
  - 单独用一个文件编写函数，函数中引用到的外部符号用 extern 引入。用编译器对该文件进行编译但不链接。
  - 编写编译器插件
- 性能优化
  几乎不能进行性能优化



Plan B

- 用加壳的方法把虚拟机加到程序镜像中
- 修改工作进程中的函数调用，将寻址的权力交给虚拟机
- 虚拟机可以灵活地进行寻址，也可以灵活地加载函数，重排函数
- 更新镜像的制作方法
  同 Plan A
- 性能优化
  - 热点路径
  - 运行时内联
  - 常量折叠



综合起来看，Plan A 的可行性更高，稳定性更强。在运行效率方面，Plan A 的开销更小，但不能做运行时优化；Plan B 的开销较大，但可以根据运行时信息进行特定的优化。具体哪种方案的性能更好，对于我们来说仍是未知数。不过整体来看，我们更倾向于使用 Plan A。


## 参考文献

1.  [How debuggers work: Part 2 - Breakpoints](https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints)
2.  [玩转utrace](https://www.ibm.com/developerworks/cn/linux/l-cn-utrace/)
