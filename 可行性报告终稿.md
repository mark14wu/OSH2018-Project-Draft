## 控制权

在对一个正在运行的工作进程进行更新时，修改它的代码段是一个不可缺少的操作。很显然，这个操作必须是原子的，因为如果程序执行到了正在被修改的代码，它可能会触发一些不可预知的错误。因此我们需要在适当的时候让工作进程交出控制权，在虚拟机完成对工作进程的更新之后，再将控制权交回给工作进程。

关于获得程序的控制权的问题，我们有以下方案

### 内核态的解决方案

在内核中，用中断的方式抢占进程的控制权。在内核态对程序执行相关更新操作后，再将控制权交还给程序。这种做法的**优点**在于**安全**和**高效**，因为代码段默认是不可写的，所以我们需要先更改代码段的读写属性，接着修改代码段内容，再把代码段改回不可写的状态。所以，直接在内核态里完成这些工作可以节省一些系统调用的开销，还可以保证修改代码操作的原子性和程序执行的安全性。

### 用户态的解决方案

* 调试器原理：软中断 (在 x86 上是 INT 3)

  调试器在给一个被调试程序打断点时，先保存断点处的指令，然后用 INT 3 指令去替换原有代码的指令。程序执行到 INT 3 时，操作系统会给调试器发信号。调试器在接收到信号之后会执行以下流程

  * 将 INT 3 改回原来的指令
  * 将代码寻址寄存器回滚一个字节
  * 允许用户和调试器进行交互（读取数据，加新的断点之类）
  * 如果继续执行，调试器会把 INT 3 再填回去，除非用户要求删除断点

  我们可以借鉴调试器的方式，通过软中断获取工作进程的控制权。这种方法的优点是可以**精确**地在某些地址停下来，这对热部署有重要意义。为了更新的安全性，我们通常不希望程序在任意时刻被中止，然后更新。我们希望程序在某些安全的时间节点停下来接收更新，所以软中断的方法可以很好的解决这个问题。软中断的缺点也很明显，它对**效率**的影响非常大。

* 虚拟机接管控制流

  和动态语言类似，我们也可以造一个虚拟机，让每一次函数调用都由虚拟机来处理。这种动态寻址方案优点是**灵活性好**，缺点是**效率不高**，而且**实现比较困难**，尤其是对已经编译好的二进制代码。

  虚拟机和工作进程之间的连接并不是一件轻松的事情，因为工作进程有自己的完整控制流，而且我们假设工作进程并未预先为虚拟机设计通信接口。如果像真正的虚拟机那样对工作进程进行解释，那么它的效率将是我们完全无法忍受的。一个可行的解决方案是，在每次函数调用时，将调用的目标函数地址压栈，并跳转到虚拟机里的控制函数，由虚拟机来处理这次函数调用。

  类似于下面将下面这个程序

  ```c
  #include <stdio.h>

  int fun(){
      return 1;
  }
  int main(){
      printf("%d\n",fun());
      return 0;
  }
  ```

  变换为

  ```c
  #include <stdio.h>

  int vm(int (*pf)()){
      return pf();
  }
  int fun(){
      return 1;
  }
  int main(){
      printf("%d\n",vm(fun));
      return 0;
  }
  ```

* 信号处理函数获得控制流

  我们可以给工作进程加壳（即给可执行文件增加一些代码），并且这些代码可以在main函数之前执行。在执行“壳”代码时，可以给工作进程注册一些信号处理函数。当需要获得控制流时，外部程序就给工作进程发信号，这时，进程执行中断，进入信号处理函数，这样就达到了获取控制流的目的。通过信号处理函数来获得控制流的方法优点是**执行效率**比较高，缺点是收到信号时停下来的**断点分布**很随机，不一定是我们想要的点。







1.  [How debuggers work: Part 2 - Breakpoints](https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints)
