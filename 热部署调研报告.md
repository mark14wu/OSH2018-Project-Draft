# 热部署调研报告

## 一、项目背景

热部署是指让应用能够在无需重新安装的情况实现更新，帮助应用快速建立动态修改能力。由于用户总是希望服务进程能保持稳定，如果服务器可以 $7 x 24$ 小时的工作的话，用户会希望永远不要重启服务器。但是，产品的功能总是在不断的丰富，只要产品仍在生命周期以内，就不可避免会面临版本升级的问题。此外，产品运营能力的提升也是靠版本更新迭代来实现，轻量级版本更新更是被视为整个产品精细化运营的基础。在另一方面而言，如果发生大规模的宕机或者运行大型程序时出现问题，通过热部署可以尽最大可能的减少损失并快速修补，而不用重新启动应用。对于移动 APP 等轻型应用，热部署可以能够缩短用户取得新版客户端的流程，改善用户体验，省去用户自行更新客户端的步骤。总而言之，如果更新过程中，业务进程不用重启，那么这将会极大地方便我们的生产、生活，升级将不再是一个令人烦恼的事情了。

## 二、立项依据

### 1. 热部署技术的应用场景

#### （1）轻量而快速的升级

热部署技术可以理解为一个动态修改代码与资源的通道，它适合于修改量较少的情况。以微信的多次发布为例，补丁大小均在300K以内，它相对于传统的发布有着很大的优势。

[![img](https://github.com/WeMobileDev/article/raw/master/assets/tinker/data.png)](https://github.com/WeMobileDev/article/blob/master/assets/tinker/data.png)

#### （2）在不宕机的情况下更新应用

在某些应用场景中，生产环境宕机会造成非常严重的后果。

比如，2012年12月22日，全球知名的开源托管服务GitHub意外遭遇了历史上最严重的一次宕机事件，而GitHub官方确认了本次宕机是在例行的软件升级过程中发生的。众所周知，GitHub一旦宕机，会使得全球各地近 2400 万名开发者的协作开发被迫中断，如果发生了代码库丢失等事故，造成的后果更是不堪设想。

## 三、重要性以及前瞻性分析

热部署是关联性强，实用性高并能显著提升各程序执行效率和开发效率的战略性技术，从谷歌微软中的大型服务器，到各类游戏厂商和手机APP的更新下载，再到我们生活中的日常使用，总会有功能不够完善需要升级，或者是犯错想要修改的时候，而如果此时程序正在运行，重启更新代价又过高，这就是热部署发挥功效的时候，比如游戏市场中，刚出的产品，在众多怀着热情的玩家疯狂的点击下载以及登陆畅玩之时，出现了bug肯定是在所难免的，如果你的游戏不支持热更新技术，那么关服是迟早的事情，为了不影响玩家体验，又能保证服务器稳定运行的情况下，修复一些轻微bug，使用热更新之最好不过的了，对用户来说能获得更好服务体验，对开发者开发时也能够适应上线需求，节省时间。再比如时常能从新闻上看到的大型服务器的宕机，对这些大公司来说，每一秒都是成千上万的损失，而更甚的是用户隐私的泄漏和公司信誉的破产，而在这种情况热部署的实现并迅速修改显得尤为重要。
热部署这一强有力的技术已经在不知不觉间影响着我们的生活，并发挥着不可或缺的作用，虽然谷歌微软等巨头都在不断地改进，但仍存在着他们力所不能及的一些有市场，有价值的需求和亟待解决的问题，而我们要做的就是在操作系统层面提供动态链接的支持来给程序提供一个通用的热部署的框架，已经支持热部署的更新很简单，但我们的重点是给开发时不支持热部署的程序提供热更新，而这是现在所做不到的。

## 四、相关工作

### Java 虚拟机上的热部署

Java 程序在执行之前，会被 Java 编译器编译为一种中间语言 : Java 字节码。这些字节通常以即 \*.class 文件的形式存在，在 Java 虚拟机执行前，\*.class 文件中有较多与类相关的元信息，例如类的字段表、属性表等。Java 字节码是一种基于栈的中间语言，既可以直接被 Java 虚拟机解释执行，也可以通过 JIT (Just-in-time compilation) 技术编译成机器码之后执行。

Java 虚拟机原生支持动态加载代码，ClassLoader 类可以用来在运行期装载新的类。但因为 Java 虚拟机的某些设计原因，它并不支持直接替换原有的类，而只能加载一个新的类。为了能实现热部署，各大组织和厂商提供了一些自己的解决方案。

* JVMTI : agent 机制

  官方规范中提供了 agent 机制，用户可以通过 `retransformClass`/`redefineClass` 操作可以在加载前和加载后动态修改类的内容，但适用范围非常受限。

* DCEVM : JVM enhancement

  DCEVM，即 Dynamic Code Evolution VM，意为代码可以动态“进化”，即我们想要的热部署。Java 社区希望能做一个增强版的 JVM，使其原生支持代码动态更新和部署。但这个项目进展比较缓慢，Full version 只支持到 Java 7 ，Light version 支持到 Java 8，而最新的 Java 版本是 Java 10。

* JBoss : 自己开发 ClassLoader 

  JBoss 是一个开源的应用服务器，它对 Java 虚拟机的类装载过程进行了一些 Hack，使其能支持热部署功能，但带来了一些的副作用：PermGen out of memory 异常。因为 JVM 的限制，热部署其实是在不断地装载新的类，所以给存储造成了较大的负担，某些特定功能的存储分区发生了溢出，引发了异常。

* 其他

  JRebel 与 JBoss 的做法接近，都是添加了一个动态链接层，这种链接层对虚拟机执行性能的影响非常大。

Java 热部署中的难点：

> 1. 两个全限定名相同的类如何加载？
> 2. 类的实例化如何获取到新的类？
> 3. 更新类的声明后，如增加类方法、实例方法；修改类方法、实例方法签名、方法体、方法注解；新增、修改类变量、实例变量；修改接口、类的继承关系，调用点怎么指向新的类？
> 4. 如果JVM使用了内联优化技术呢？
> 5. 如何保证反射正确，比如调用`Class`的`getName()`、`getMethods()`、`getField()`等方法时如何获取到新的类？
> 6. 如果用了容器或者框架，修改JavaConfig或者XML后，怎么反映到容器里？

### Lua 等动态语言的热部署

动态语言如 Lua, Python, PHP, Closure 等都有自己的热部署方案。因为对于动态语言来说，代码就是数据，什么时候想改代码了，直接重新加载即可，因为虚拟机的代码是没有发生改变的，只不过是虚拟机所持有的数据发生了变化，导致它的控制流发生改变。对操作系统来说，这个更新是不可见的。

Python，PHP 等的代码热部署常用于服务器的热部署，而 Lua 因为其常常作为游戏的脚本语言而经常用于游戏的热部署。Closure 是 JVM 上的动态语言，因此有时也作为 JVM 程序热部署的替代方案。

动态语言执行代码的方式一般有两种，一种是直接执行，一种是通过 JIT 技术编译后执行。总的来说，动态语言数据格式灵活，运行期反射强大。

### Erlang 与 Actor 并发模型

Erlang 是爱立信公司为了电话系统的热部署而专门开发的编程语言，采用 Actor 并发模型，在虚拟机中实现轻量级进程。

![Related image](https://image.slidesharecdn.com/voip2day2014nksip-141008082234-conversion-gate01/95/nksip-the-erlang-sip-application-server-9-638.jpg?cb=1412756937)

一个 Application（应用）下面有一些 Supervisor（监控进程）和一些 Worker （工作进程），这里的进程并不是操作系统意义下的进程，实际上，它比线程还轻。它自己有一些显式声明的状态和一个信箱，信箱用于接收来着其它进程的消息，然后对消息进行处理。在没有消息的时候，进程处于阻塞状态，而不是空转状态，这为系统节省了开销。Actor 的启动非常迅速，而且因为是基于消息的，所以一个 Actor 可以迅速的关闭和重启，并继续处理刚才信箱中的消息，而这一切在外界调用者看来就像没有发生一样。再加上每个 Worker 都有 Supervisor，因此 Worker 在重新启动后很容易继续刚才的工作。对于整个系统而言，如果需要热部署，则只需要分批换下各个 Actor 即可，这是安全、开销很小的热部署方案。

Scala 语言的库 Akka Actor 同样提供了 Actor 进程模型，Akka Actor 的文档中提到 Akka Actor 也支持安全的热部署。

### ELF文件代码嵌入

相关工作已经做到可以在不知道源码的情况下，对ELF文件进行代码注入。

### 主被动分区技术

这是与系统更新相关的技术，用两个分区来安装系统，一个叫主动分区，是实际加载的分区，一个叫被动分区，用于等待更新。一旦更新发布，被动分区就应用更新，并在下一次启动时与之前的主动分区交换位置。

### 启发

热部署在实现上的重点在于动态加载代码和原有控制流的改变，对于动态语言来说，因为控制流完全由虚拟机控制，所以可以在虚拟机层面提供热部署机制。而对于 native 程序，加载和控制流有一部分是由操作系统控制，一部分是硬件控制的，因此我们可以借鉴 Lua 等动态语言的思路，对已运行的程序进行热部署。

热部署在理论上的难点在于状态的管理，即前后程序的无缝衔接，已有的工作如何转交，如何保证热部署的安全。对于无状态的程序，如动态链接库中的库函数，如果不更改函数类型，那么更新就是较为安全的。但对于状态丰富的程序而已，如何进行安全地热更新仍然是一个需要解决的问题。Actor 模型提供了一种可行的解决方案，但有一些学习成本和已有代码的迁移成本。

## 五、参考文献

1. [几种常见的JVM热部署技术及实现难点浅谈](https://segmentfault.com/a/1190000011174467)
1. [DCEVM](https://dcevm.github.io/)
1. [HotSwap和JRebel原理](http://www.cnblogs.com/winner-0715/p/5136489.html)
1. [实现增强的java class hotswap (三) 解决方案 续](http://argan.iteye.com/blog/444633)
1. [实现增强的java class hotswap (三) 解决方案](http://argan.iteye.com/blog/443611)
1. [Java是否可以做到修改类而不用重启JVM？](https://www.zhihu.com/question/28833796)
1. [深入探索 Java 热部署](https://www.ibm.com/developerworks/cn/java/j-lo-hotdeploy/)
1. [4 free ways to hot-swap code on the JVM](https://sites.google.com/a/athaydes.com/renato-athaydes/posts/4freewaystohot-swapcodeonthejvm)
1. [What makes hot deployment a “hard problem”?](https://stackoverflow.com/questions/660437/what-makes-hot-deployment-a-hard-problem)
1. [ELF格式可执行文件的代码嵌入技术](http://xueshu.baidu.com/s?wd=paperuri:(eea3c4ce4546792b61af7f95db469907)&filter=sc_long_sign&sc_ks_para=q%3DELF%E6%A0%BC%E5%BC%8F%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B5%8C%E5%85%A5%E6%8A%80%E6%9C%AF&tn=SE_baiduxueshu_c1gjeupa&ie=utf-8&sc_us=12017230711330739494)
1. [What is Core-OS](http://www.infoq.com/cn/articles/what-is-coreos)
1. [Learn You some Erlang](http://learnyousomeerlang.com/content)
1. [Akka Actor](https://doc.akka.io/docs/akka/2.0/java/untyped-actors.html)